#!/usr/bin/env perl
# -*- mode: cperl; mode: follow -*-
#

use strict;
use warnings;
use diagnostics;

use Crypt::SSSS;
use Data::Dumper;
use Getopt::Long  qw(:config no_ignore_case auto_help auto_version);;
use Pod::Usage    qw(pod2usage);
use MIME::Base64;
use File::Basename;
use Try::Tiny;

my $is_crypt_primes = eval {
  require Crypt::Primes; # qw(maurer);
  Crypt::Primes->import( qw(maurer) );
  1;
  };

my  @PROGARG = ($0, @ARGV);
my  $PROGNAM = fileparse($0);
our $VERSION = '0.6';

my $k = 3;
my $b; # prime bitsize
my $p; # prime, Crypt::SSSS default is 527
my $n; # default: equals to k
my @m = ();
my $d = 0; # to ssss_distribute
my $r = 0; # to ssss_reconstruct
my $s = 0; # to save shares
my $v = 0;
my @I = (); # chunks/files index/es to reconstruct secret from
my $i;
my $P = '';

my $getopt_result =
  GetOptions (
	      'b|prime-bits=i'    => \$b,
	      'd|distribute'      => \$d,
	      'h|help'            => sub { pod2usage(-exitval => 0, -verbose => 2); exit 0 },
	      'i|indexes=i'       => \@I,
	      'k|threshold=i'     => \$k,
	      'm|message=s'       => \@m,
	      'n|num-of-shares=i' => \$n,
	      'p|prime-number=i'  => \$p,
	      'r|reconstruct'     => \$r,
	      's|save'            => \$s,
	      'v|verbose+'        => \$v,
	      'P|prefix=s'        => \$P,
	      'V|version'         => sub { print "$PROGNAM, version $VERSION\n"; exit 0 },
	     );

if ( ! $getopt_result ) {
  print "$getopt_result\n\n";
  exit 2;
}

print " Invocation: ", join(' ', @PROGARG), "\n" if $v;

###############################
# VALIDATION & INITIALISATION #
###############################
$n = $k if ! defined $n;

if ( ! $d && ! $r ) {
  print "ERROR: you should provide -d or -r\n";
  pod2usage(-exitval => 0, -verbose => 2);
  exit 2;
}

if ( $d && $r ) {
  print "ERROR: you should provide only one, either -d or -r\n";
  pod2usage(-exitval => 0, -verbose => 2);
  exit 2;
}

if ( ! scalar @m && ! $s ) {
  print "ERROR: neither -m (message) has been provided, no -s (to reconstruct from files)\n";
  pod2usage(-exitval => 0, -verbose => 2);
  exit 2;
}

print Dumper( @m ) if scalar @m && $v > 2;

if ( defined $b && defined $p ) {
  print "ERROR: you can provide only -b or -p\n";
  exit 2;
} elsif ( ! defined $b && ! defined $p && $is_crypt_primes ) {
  $b = 16;
} elsif ( ! defined $b && ! defined $p && ! $is_crypt_primes ) {
  $p = 527;
}
if ( ! defined $p && $is_crypt_primes ) {
  $p = maurer ( Size => $b, Verbosity => $v > 2 ? 1 : 0 );
  print 'Prime bit.s: ', $b, "\n" if $v;
}
print 'Prime num. : ', $p, "\n" if $v;

if ( ! scalar @I ) {
  $i = $k;
  push @I, $i-- while ( $i );
  print Dumper( @I ) if $v > 3;
}

my $fn;

##############
# DISTRIBUTE #
##############
my ( @sh, $to_b64, $b64, $msg, $message, $msg_len);
if ( $d ) {
  $msg = join('', @m);
  $message = pack('N', length($msg)) . $msg;
  print Dumper( $message ) if $v > 2;
  my $shares = ssss_distribute( message => $message, k => $k, n => $n, p => $p );
  print Dumper( $shares ) if $v > 3;

  foreach ( sort( keys (%{$shares})) ) {
    $to_b64 = $shares->{$_}->binary;
    print Dumper( $to_b64 ) if $v > 2;
    $b64  = encode_base64( $to_b64, '' );
    push @sh, sprintf("%03s-%s", $_, $b64 ); # hardcode with 3 char padding

    if ( $s ) {
      $fn = sprintf("%s%03i.dat", $P, $_);
      open my $fh, '>', $fn || do { print "\nERROR: Can't open > $fn: $!\n"; exit 2; };
      print $fh $to_b64;
      close $fh || do { print "\nERROR: Can't close file $fn: $!\n"; exit 2; };
    }
  }

  print "$_\n" foreach ( @sh );
}

###############
# RECONSTRUCT #
###############

# The Problem
#
# Crypt::SSSS works with fixed-size blocks internally. When a message doesn't
# fill the block size completely, the module pads it with null bytes to reach
# the required block boundary. During reconstruction, these padding null bytes
# are included in the result.
#
# We need to handle the padding removal ourselves.

  if ( $r ) {

  my $rshare = {};
  $i = 1;
  if ( $s ) {
    foreach ( @I ) {
      $fn = sprintf("%s%03i.dat", $P, $_);
      open my $fh, '<', $fn or do { print "\nERROR: Can't open < $fn (is prefix needed?): $!\n"; exit 2; };
      $rshare->{$_} = do {
	local $/; # slurp!
	<$fh>;
      };
      close $fh || do { print "\nERROR: Can't close file $fn: $!\n"; exit 2; };
    }
  } else {
    ### %{$rshare} = map { int(substr( $_, 0, 3 )) => decode_base64(substr( $_, 4 )) } sort @m;
    %{$rshare} = map {
      my $index = int(substr($_, 0, 3));
      my $b64_data = substr($_, 4);
      my $binary_data = decode_base64($b64_data);
      ($index => $binary_data);
    } @m;
  }

  print Dumper( $rshare ) if $v > 3; # be carefull

  my $message = '';
  my $err;
  $message = try { ssss_reconstruct(p => $p, shares => $rshare); } catch { $err = $_; };

  # Extract original message using stored length
  $msg_len = unpack('N', substr($message, 0, 4));
  $message = substr($message, 4, $msg_len);

  if ( defined $err ) {
    print "sssstool catch: unpack exception on reconstruct attempt: ", Dumper( $err ) if $v;
    print "\nERROR: unpack failed, wrong option/s for reconstruct\n";
    exit 2;
  }

  if ( $v ) {
    print "Secret     : $message\n";
  } else {
    print "$message\n";
  }

}

__END__

=head1 NAME

sssstool - split or reconstruct secrets using Shamir's Secret Sharing Scheme

=head1 SYNOPSIS

    sssstool <-d | -r> [OPTIONS]

    # Distribution examples:
    sssstool -d -k 3 -n 5 -m "my secret" -v
    sssstool -d -k 2 -n 3 -m "part1" -m "part2" -s -P backup-

    # Reconstruction examples:
    sssstool -r -m "001-base64data" -m "002-base64data" -m "003-base64data"
    sssstool -r -s -P backup- -i 1 -i 3 -v

=head1 DESCRIPTION

B<sssstool> is a command-line utility for splitting secrets into multiple shares
and reconstructing them using Shamir's Secret Sharing Scheme (SSSS). This
cryptographic technique allows you to split a secret into N shares, where any
K shares are sufficient to reconstruct the original secret, but K-1 shares
reveal no information about the secret.

The tool supports two modes of operation:

=over 4

=item * B<Distribution mode> (-d): Splits a secret into multiple shares

=item * B<Reconstruction mode> (-r): Reconstructs the original secret from shares

=back

Shares can be output as base64-encoded strings to stdout or saved to individual
files for secure storage and distribution.

=head1 OPTIONS

=head2 Mode Selection (Required)

=over 4

=item B<-d, --distribute>

Enable distribution mode to split a secret into shares.

=item B<-r, --reconstruct>

Enable reconstruction mode to recover the original secret from shares.

=back

=head2 Secret Input/Output

=over 4

=item B<-m, --message> I<STRING>

Message (secret) to distribute in distribution mode, or base64-encoded share
in reconstruction mode. Can be specified multiple times to concatenate parts
or provide multiple shares.

Examples:
    -m "my secret"                    # Single secret
    -m "part1" -m "part2"            # Concatenated secret
    -m "001-base64data"              # Share for reconstruction

=item B<-s, --save>

Save shares to separate files during distribution, or read shares from files
during reconstruction. Files are named using the pattern: I<PREFIX>XXX.dat
where XXX is a zero-padded 3-digit share index.

=back

=head2 Threshold Parameters

=over 4

=item B<-k, --threshold> I<NUMBER>

Threshold value - the minimum number of shares required to reconstruct the
secret. Must be less than or equal to the number of shares (-n).
Default: 3

=item B<-n, --num-of-shares> I<NUMBER>

Total number of shares to generate during distribution.
Default: same as threshold (-k)

=back

=head2 Prime Number Selection

=over 4

=item B<-p, --prime-number> I<NUMBER>

Specify an exact prime number to use for calculations. Cannot be used with -b.
Default: 527 (if Crypt::Primes is not available)

=item B<-b, --prime-bits> I<NUMBER>

Bit size for generating a random prime number. Requires Crypt::Primes module.
Cannot be used with -p.
Default: 16 (if Crypt::Primes is available)

=back

=head2 File Operations

=over 4

=item B<-P, --prefix> I<STRING>

Prefix for share filenames when using -s option.
Default: empty string

=item B<-i, --indexes> I<NUMBER>

File indexes to read during reconstruction with -s option. Can be specified
multiple times to select specific share files.
Default: reads files 1 through k (threshold value)

=back

=head2 Utility Options

=over 4

=item B<-v, --verbose>

Enable verbose output. Can be specified multiple times to increase verbosity:
    -v      Basic verbose information
    -vv     More detailed output
    -vvv    Debug-level output with data dumps

=item B<-h, --help>

Display this help message and exit.

=item B<-V, --version>

Display version information and exit.

=back

=head1 EXAMPLES

=head2 Basic Distribution and Reconstruction

Split a secret into 5 shares where any 3 are needed for reconstruction:

    sssstool -d -k 3 -n 5 -m "my important secret"

Reconstruct the secret from 3 base64-encoded shares:

    sssstool -r -m "001-ABCD..." -m "003-EFGH..." -m "005-IJKL..."

=head2 File-based Operations

Distribute and save shares to files:

    sssstool -d -k 2 -n 4 -m "classified information" -s -P secure-

This creates files: secure-001.dat, secure-002.dat, secure-003.dat, secure-004.dat

Reconstruct from saved files:

    sssstool -r -s -P secure- -i 1 -i 3 -v

=head2 Multi-part Secrets

Split a secret composed of multiple parts:

    sssstool -d -k 3 -n 5 -m "part1" -m "part2" -m "part3" -s -P backup-

=head2 Custom Prime Numbers

Use a specific prime number:

    sssstool -d -k 3 -n 5 -m "secret" -p 1009

Generate a larger random prime (requires Crypt::Primes):

    sssstool -d -k 3 -n 5 -m "secret" -b 32 -v

=head1 SECURITY CONSIDERATIONS

=over 4

=item * Store shares in separate, secure locations

=item * Use appropriate threshold values (k) for your security requirements

=item * Larger prime numbers provide better security but slower performance

=item * The secret is only as secure as the least secure share

=item * Shares should be transmitted through secure channels

=back

=head1 DEPENDENCIES

=over 4

=item * B<Crypt::SSSS> - Core secret sharing functionality (required)

=item * B<Crypt::Primes> - Random prime generation (optional, for -b option)

=item * B<MIME::Base64> - Base64 encoding/decoding (required)

=item * B<Try::Tiny> - Exception handling (required)

=back

=head1 EXIT STATUS

=over 4

=item * B<0> - Success

=item * B<2> - Error (invalid options, file operations, reconstruction failure)

=back

=head1 LIMITATIONS

=over 4

=item * Share data contains padding and length information

=item * File operations require appropriate filesystem permissions

=item * Prime generation requires Crypt::Primes module

=item * Base64 encoding increases share size by ~33%

=back

=head1 SEE ALSO

L<Crypt::SSSS>, L<Crypt::Primes>

L<https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing>

L<http://point-at-infinity.org/ssss/> - Original ssss implementation

L<https://github.com/gburca/ssss-js> - JavaScript implementation

=head1 AUTHOR

Zeus Panchenko <zeus@gnu.org.ua>

=head1 COPYRIGHT AND LICENSE

Copyright 2025 Zeus Panchenko.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

=cut
